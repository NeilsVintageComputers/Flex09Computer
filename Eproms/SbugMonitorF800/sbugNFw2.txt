* NAM SBUGNFW2.TXT (SBUG18 MP-09) MONITOR
* OPT PAG
* PAG

* SBUG V1.8 MONITOR PROGRAM MODIFIED FOR THE 
* NEIL FARRALL FLEX-09 CPU BOARD 
* WITH 56K RAM MEMORY BOARD    0000 - DFFF

*REMOVED REFERENCES TO THE DAT TRANSLATION HARDWARE
*REMOVED THE D, L, P COMMANDS
*D COMMAND REPLACED WITH A JSR TO SECOND EPROM AT F000





*       *** COMMANDS ***

* CONTROL A   = ALTER THE "A" ACCUMULATOR
* CONTROL B   = ALTER THE "B" ACCUMULATOR
* CONTROL C   = ALTER THE CONDITION CODE REGISTER
* CONTROL D   = ALTER THE DIRECT PAGE REGISTER
* CONTROL P   = ALTER THE PROGRAM COUNTER
* CONTROL U   = ALTER USER STACK POINTER
* CONTROL X   = ALTER "X" INDEX REGISTER
* CONTROL Y   = ALTER "Y" INDEX REGISTER
* B hhhh      = SET BREAKPOINT AT LOCATION $hhhh
* D           = JUMP INSTRUCTION TO SECOND 2716
*               (RETURN BACK USING RTS WHEN DONE)
* U           = BOOT A SWTPC 5 INCH FLOPPY SYSTEM
* E ssss-eeee = EXAMINE MEMORY FROM STARTING ADDRESS ssss
*              -TO ENDING ADDRESS eeee.
* G           = CONTINUE EXECUTION FROM BREAKPOINT OR SWI
* L   = REMOVED
* M hhhh      = EXAMINE AND CHANGE MEMORY LOCATION hhhh
* P   = REMOVED
* Q ssss-eeee = TEST MEMORY FROM ssss TO eeee
* R           = DISPLAY REGISTER CONTENTS
* S           = DISPLAY STACK FROM ssss TO $DFC0
* X           = REMOVE ALL BREAKPOINTS


TSTPAT EQU $55AA  TEST PATTERN



       ORG $DFC0
STACK  		RMB 2  		;TOP OF INTERNAL STACK / USER VECTOR
SWI3   		RMB 2  		;SOFTWARE INTERRUPT VECTOR #3
SWI2   		RMB 2  		;SOFTWARE INTERRUPT VECTOR #2
FIRQ   		RMB 2  		;FAST INTERRUPT VECTOR
IRQ    		RMB 2  		;INTERRUPT VECTOR
SWI    		RMB 2  		;SOFTWARE INTERRUPT VECTOR
SVCVO  		RMB 2  		;SUPERVISOR CALL VECTOR ORGIN
SVCVL  		RMB 2  		;SUPERVISOR CALL VECTOR LIMIT
LRARAM 	RMB 16 		;LRA ADDRESSES
CPORT  		RMB 2  		;RE-VECTORABLE CONTROL PORT
ECHO   		RMB 1  		;ECHO FLAG
BPTBL  		RMB 24 		;BREAKPOINT TABLE BASE ADDR

ACIAS  		EQU $E000  	;CONTROL PORT ($E000 or $E004)

*DISK CONTROLLER
Comreg 		EQU $E018  	;COMMAND REGISTER
Drvreg 		EQU $E014  	;DRIVE REGISTER
Secreg 		EQU $E01A  	;SECTOR REGISTER
Datreg 		EQU $E01B  	;DATA REGISTER

Eprom2          EQU     $F000   ;START ADDRESS OF SECOND 2716

 
 ORG $F800


 	FDB 	MONITOR
 	FDB 	NEXTCMD
 	FDB 	INCH
 	FDB 	INCHE
 	FDB 	INCHEK
 	FDB 	OUTCH
 	FDB 	PDATA
 	FDB 	PCRLF
 	FDB 	PSTRNG
 	FDB 	LRA

* MONITOR

* VECTOR ADDRESS STRING IS.....
* $F8A1-$F8A1-$F8A1-$F8A1-$F8A1-$FAB0-$FFFF-$FFFF

MONITOR 	LDX #RAMVEC 	;POINT TO VECTOR ADDR. STRING
 		LDY  #STACK 	;POINT TO RAM VECTOR LOCATION
 		LDB  #$10 	;BYTES TO MOVE = 16
LOOPA 		LDA  ,X+ 	;GET VECTOR BYTE
 		STA  ,Y+   	;PUT VECTORS IN RAM / $DFC0-$DFCF
 		DECB 		;SUBTRACT 1 FROM NUMBER OF BYTES TO MOVE
 		BNE LOOPA 	;CONTINUE UNTIL ALL VECTORS MOVED

* CONTENTS     FROM         TO      FUNCTION
*  $F8A1       $FE40      $DFC0     USER-V
*  $F8A1       $FE42      $DFC2     SWI3-V
*  $F8A1       $FE44      $DFC4     SWI2-V
*  $F8A1       $FE46      $DFC6     FIRQ-V
*  $F8A1       $FE48      $DFC8     IRQ-V
*  $FAB0       $FE4A      $DFCA     SWI-V
*  $FFFF       $FE4C      $DFCC     SVC-VO
*  $FFFF       $FE4E      $DFCE     SVC-VL

 		LDX  #ACIAS  	;GET CONTROL PORT ADDR.
 		STX  CPORT   	;STORE ADDR. IN RAM
 		LBSR XBKPNT 	;CLEAR OUTSTANDING BREAKPOINTS

 		LDB  #12   	 ;CLEAR 12 BYTES ON STACK
CLRSTK		CLR  ,-S
 		DECB
 		BNE  CLRSTK

 		LEAX MONITOR,PCR  ;SET PC TO SBUG-E ENTRY
 		STX  10,S 	;ON STACK

 		LDA  #$D0  	;PRESET CONDITION CODES ON STACK
 		STA  ,S
 		TFR  S,U




 		LBSR ACINIZ  	;INITIALIZE CONTROL PORT
 		LDX  #MSG1  	;POINT TO 'SBUG 1.8' MESSAGE	
		LBSR PDATA  	;PRINT MSG

 		LDX  #LRARAM  	;POINT TO LRA RAM STORAGE AREA
 		CLRA 		;START TOTAL AT ZERO
 		LDB  #13  	;TOTAL UP ALL ACTIVE RAM MEMORY
FNDREL 		TST  B,X 	;TEST FOR RAM AT NEXT LOC.
 		BEQ  RELPAS 	;IF NO RAM GO TO NEXT LOC.
 		ADDA #4 	;ELSE ADD 4K TO TOTAL
 		DAA 		;ADJ. TOTAL FOR DECIMAL
RELPAS 		DECB 		;SUB. 1 FROM LOCS. TO TEST
 		BPL  FNDREL  	;PRINT TOTAL OF RAM
 		LBSR OUT2H 	;OUTPUT HEX BYTE AS ASCII
 		LDX  #MSG2  	;POINT TO MSG 'K' CR/LF + 3 NULS
	 	LBSR PDATA  	;PRINT MSG





***** NEXTCMD *****

NEXTCMD 	LDX  #MSG3   	;POINT TO MSG ">"
 		LBSR PSTRNG 	;PRINT MSG

 		LBSR INCH 	;GET ONE CHAR. FROM TERMINAL
 		ANDA #$7F 	;STRIP PARITY FROM CHAR.

 		CMPA #$0D 	;IS IT CARRIAGE RETURN ?
 		BEQ  NEXTCMD 	;IF CR THEN GET ANOTHER CHAR.

 		TFR  A,B 	;PUT CHAR. IN "B" ACCUM.
 		CMPA #$20 	;IS IT CONTROL OR DATA CHAR ?
 		BGE  PRTCMD 	;IF CMD CHAR IS DATA, PRNT IT

 		LDA  #'^ 		;ELSE CNTRL CHAR CMD SO...
 		LBSR OUTCH 	;PRINT "^"
 		TFR  B,A 	;RECALL CNTRL CMD CHAR
 		ADDA #$40 	;CONVERT IT TO ASCII LETTER

PRTCMD          LBSR OUTCH      ;PRNT CMD CHAR
 		LBSR OUT1S 	;PRNT SPACE
 		CMPB #$60
 		BLE NXTCH0
 		SUBB #$20


***** DO TABLE LOOKUP *****
*   FOR COMMAND FUNCTIONS


NXTCH0          LDX #JMPTAB     ;POINT TO JUMP TABLE
NXTCHR          CMPB ,X+        ;DOES COMMAND MATCH TABLE ENTRY ?
 		BEQ  JMPCMD 	;BRANCH IF MATCH FOUND

 		LEAX 2,X 	;POINT TO NEXT ENTRY IN TABLE
 		CMPX #TABEND 	;REACHED END OF TABLE YET ?
 		BNE  NXTCHR 	;IF NOT END, CHECK NEXT ENTRY

 		LDX  #MSG4  	;POINT TO MSG "WHAT?"
 		LBSR PDATA  	;PRINT MSG
 		BRA  NEXTCMD 	;IF NO MATCH, PRMPT FOR NEW CMD

JMPCMD          JSR  [,X]       ;JUMP TO COMMAND ROUTINE
 		BRA  NEXTCMD 	;PROMPT FOR NEW COMMAND

*
* "G" GO OR CONTINUE
GO 	TFR  U,S
RTI 	RTI

* "R" DISPLAY REGISTERS
REGSTR 	LDX  #MSG5 	;POINT TO MSG " - "
 		LBSR PSTRNG ;PRINT MSG
 		LBSR PRTSP 	;$FCBF
 		LBSR PRTUS 	;$FCCA
 		LBSR PRTDP 	;$FCD5	
		LBSR PRTIX 	;$FCE0
 		LBSR PRTIY 	;$FCEB
 		LDX  #MSG5 	;POINT TO MSG " - "
 		LBSR PSTRNG ;PRINT MSG
 		LBSR PRTPC 	;$FCF5
 		LBSR PRTA 	;$FCFF
 		LBSR PRTB 	;$FD09
 		LBRA PRTCC 	;$FD13


* ALTER "PC" PROGRAM COUNTER
ALTRPC          LBSR PRTPC      ;$FCF5 PRINT MSG " PC = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR IN1ADR 	;GET NEW CONTENTS FOR "PC"
 		BVS  ALTPCD 	;EXIT IF INVALID HEX
 		STX  10,U 	;POKE IN NEW CONTENTS
ALTPCD 	RTS


* ALTER "U" USER STACK POINTER
ALTRU           LBSR PRTUS      ;$FCCA PRINT MSG " US = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR IN1ADR
 		BVS  ALTUD
 		STX  8,U
ALTUD 		RTS

*
* ALTER "Y" INDEX REGISTER
ALTRY           LBSR PRTIY      ;PRINT MSG " IY = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR IN1ADR
 		BVS  ALTYD
 		STX  6,U   	;$F8F0
ALTYD 		RTS


* ALTER "X" INDEX REGISTER
ALTRX 	LBSR PRTIX 	;$FCE0 PRINT MSG " IX = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR IN1ADR
 		BVS  ALTXD
 		STX  4,U
ALTXD 	RTS

* ALTER "DP" DIRECT PAGE REGISTER
ALTRDP 		LBSR PRTDP 	;$FCD5 PRINT MSG " DP = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS  ALTDPD
 		STA  3,U
ALTDPD 		RTS


* ALTER "B" ACCUMULATOR
ALTRB 	LBSR PRTB 	;$FD09 PRINT MSG " B = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS  ALTBD
 		STA  2,U
ALTBD 		RTS       		;$F91C


* ALTER "A" ACCUMULATOR
ALTRA 	LBSR PRTA 	;$FCFF RINT MSG " A = "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS  ALTAD
 		STA  1,U
ALTAD 		RTS


* ALTER "CC" REGISTER
ALTRCC 	LBSR PRTCC 	;$FD13 PRINT MSG " CC: "
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS  ALTCCD
 		ORA  #$80 	;SETS "E" FLAG IN PRINT LIST
 		STA  ,U
ALTCCD 		RTS




***** "M" MEMORY EXAMINE AND CHANGE *****
MEMCHG 	LBSR IN1ADR  	;INPUT ADDRESS
 		BVS  CHRTN  	;IF NOT HEX, RETURN
 		TFR  X,Y 	;SAVE ADDR IN "Y"
MEMC2 	LDX  #MSG5 	;POINT TO MSG " - "
 		LBSR PSTRNG 	;PRINT MSG
 		TFR  Y,X 		;FETCH ADDRESS
 		LBSR OUT4H 	;PRINT ADDR IN HEX
 		LBSR OUT1S 	;OUTPUT SPACE
 		LDA  ,Y 		;GET CONTENTS OF CURRENT ADDR.
 		LBSR OUT2H 	;OUTPUT CONTENTS IN ASCII
 		LBSR OUT1S 	;OUTPUT SPACE
 		LBSR BYTE 	;LOOP WAITING FOR OPERATOR INPUT
 		BVC  CHANGE 	;IF VALID HEX GO CHANGE MEM. LOC.
 		CMPA #8  	;IS IT A BACKSPACE (CNTRL H)?
 		BEQ  MEMC2 	;PROMPT OPERATOR AGAIN
 		CMPA #$18  	;IS IT A CANCEL (CNTRL X)?
 		BEQ  MEMC2 	;PROMPT OPERATOR AGAIN
 		CMPA #'^  	;IS IT AN UP ARROW?
 		BEQ  BACK  	;DISPLAY PREVIOUS BYTE
 		CMPA #$D  	;IS IT A CR?
 		BNE  FORWRD  	;DISPLAY NEXT BYTE
CHRTN 	RTS 		;EXIT ROUTINE


CHANGE 	STA ,Y  		;CHANGE BYTE IN MEMORY
 		CMPA ,Y  	;DID MEMORY BYTE CHANGE?
 		BEQ  FORWRD    ;$F972
 		LBSR OUT1S 	;OUTPUT SPACE
 		LDA  #'?  	;LOAD QUESTION MARK
 		LBSR OUTCH  	;PRINT IT
FORWRD 	LEAY 1,Y 	;POINT TO NEXT HIGHER MEM LOCATION
 		BRA  MEMC2 	;PRINT LOCATION & CONTENTS
BACK 		LEAY -1,Y 	;POINT TO LAST MEM LOCATION
 		BRA  MEMC2 	;PRINT LOCATION & CONTENTS




* "S" DISPLAY STACK
* HEX-ASCII DISPLAY OF CURRENT STACK CONTENTS FROM
* CURRENT STACK POINTER TO INTERNAL STACK LIMIT.
DISSTK 	LBSR PRTSP 	;PRINT CURRENT STACK POINTER
 		TFR  U,Y
 		LDX  #STACK 	;LOAD INTERNAL STACK AS UPPER LIMIT
 		LEAX -1,X 	;POINT TO CURRENT STACK
 		BRA  MDUMP1 	;ENTER MEMORY DUMP OF STACK CONTENTS


* "E" DUMP MEMORY FOR EXAMINE IN HEX AND ASCII
* AFTER CALLING 'IN2ADR' LOWER ADDRESS IN Y-REG.
*                        UPPER ADDRESS IN X-REG.
* IF HEX ADDRESSES ARE INVALID (V)=1.
MEMDUMP 	LBSR IN2ADR 	;INPUT ADDRESS BOUNDRIES
 		BVS  EDPRTN 	;NEW COMMAND IF ILLEGAL HEX
MDUMP1 	PSHS Y 		;COMPARE LOWER TO UPPER BOUNDS
 		CMPX ,S++ 	;LOWER BOUNDS > UPPER BOUNDS?
 		BCC  AJDUMP 	;IF NOT, DUMP HEX AND ASCII
EDPRTN 	RTS

* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDRIES.

* IF LOWER ADDR = $4532
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530.

* IF UPPER ADDR = $4567
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570.

* ENTER WITH LOWER ADDRESS IN X-REG.
*           -UPPER ADDRESS ON TOP OF STACK.

AJDUMP 	TFR  X,D 	;GET UPPER ADDR IN D-REG
 		ADDD #$10 	;ADD 16 TO UPPER ADDRESS
 		ANDB #$F0 	;MASK TO EVEN 16 BYTE BOUNDRY
 		PSHS A,B 	;SAVE ON STACK AS UPPER DUMP LIMIT
 		TFR  Y,D   	;$F9A5 GET LOWER ADDRESS IN D-REG
 		ANDB #$F0 	;MASK TO EVEN 16 BYTE BOUNDRY
 		TFR  D,X 	;PUT IN X-REG AS LOWER DUMP LIMIT
NXTLIN 	CMPX ,S 	;COMPARE LOWER TO UPPER LIMIT
 		BEQ  SKPDMP 	;IF EQUAL SKIP HEX-ASCII DUMP
 		LBSR INCHEK 	;CHECK FOR INPUT FROM KEYBOARD
 		BEQ  EDUMP 	;IF NONE, CONTINUE WITH DUMP
SKPDMP 	LEAS 2,S 	;READJUST STACK IF NOT DUMPING
 		RTS

* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS.

EDUMP 	PSHS X 		;PUSH LOWER ADDR LIMIT ON STACK
 		LDX  #MSG5 	;POINT TO MSG " - "
 		LBSR PSTRNG 	;PRINT MSG
 		LDX  ,S 		;LOAD LOWER ADDR FROM TOP OF STACK
 		LBSR OUT4H 	;PRINT THE ADDRESS LBSR OUT2S PRINT 2 SPACES
 		LDB  #$10 	;LOAD COUNT OF 16 BYTES TO DUMP
ELOOP 	LDA  ,X+ 		;GET FROM MEMORY HEX BYTE TO PRINT
 		LBSR OUT2H 	;OUTPUT HEX BYTE AS ASCII
 		LBSR OUT1S 	;OUTPUT SPACE
 		DECB      	;$F9D1 DECREMENT BYTE COUNT
 		BNE  ELOOP 	;CONTINUE TIL 16 HEX BYTES PRINTED

* PRINT 16 ASCII CHARACTERS
* IF NOT PRINTABLE OR NOT VALID
* ASCII PRINT A PERIOD (.)
 		LBSR OUT2S 	;2 SPACES
 		LDX  ,S++ 	;GET LOW LIMIT FRM STACK - ADJ STACK
 		LDB  #$10 	;SET ASCII CHAR TO PRINT = 16
EDPASC 	LDA  ,X+ 		;GET CHARACTER FROM MEMORY
 		CMPA #$20 	;IF LESS THAN $20, NON-PRINTABLE?
 		BCS  PERIOD 	;IF SO, PRINT PERIOD INSTEAD
 		CMPA #$7E 	;IS IT VALID ASCII?
 		BLS  PRASC 	;IF SO PRINT IT
PERIOD 	LDA  #'. 		;LOAD A PERIOD (.)
PRASC 	LBSR OUTCH 	;PRINT ASCII CHARACTER
 		DECB 		;DECREMENT COUNT
 		BNE  EDPASC
 		BRA  NXTLIN



***** "Q" MEMORY TEST *****
MEMTST 	CLR  ,-S 		;CLEAR BYTE ON STACK
 		CLR  ,-S 		;CLEAR ANOTHER BYTE
 		LBSR IN2ADR 	;GET BEGIN(Y) & END(X) ADDR. LIMITS
 		PSHS X,Y 	;SAVE ADDRESSES ON STACK
 		BVS  ADJSK6 	;EXIT IF NOT VALID HEX
 		CMPX 2,S 	;COMPARE BEGIN TO END ADDR.
 		BCS  ADJSK6 	;EXIT IF BEGIN > END ADDR.
 		LBSR OUT1S 	;OUTPUT SPACE
MEMSET 	TFR  Y,D 	;PUT BEGIN ADDR. IN 'D'-ACCUM.
 		ADDD 4,S 	;ADD PASS COUNT TO BEGIN ADDR
 		PSHS B 		;ADD LS BYTE TO MS BYTE OF BEGIN ADDR
 		ADDA ,S+
 		STA  ,Y+ 	;SAVE THIS DATA BYTE AT BEGIN ADDR
 		CMPY ,S 	;COMPARE END TO BEGIN ADDR
 		BCS  MEMSET 	;IF BEGIN LOWER, CONTINUE TO SET MEMORY
 		LDY  2,S 	;RELOAD BEGIN ADDRESS
TEST1 	TFR  Y,D 	;PUT BEGIN ADDR IN 'D'-ACC.
 		ADDD 4,S 	;ADD PASS COUNT TO ADDRESS
 		PSHS A 		;ADD MS BYTE TO LS BYTE OF ADDRESS
 		ADDB ,S+
 		EORB ,Y+ 	;EX-OR THIS DATA WITH DATA IN MEMORY LOC.
 		BEQ  GUDPAS 	;IF (Z) SET, MEMORY BYTE OK
 		LDX  #MSG5 	;POINT TO MSG " - "
 		LBSR PSTRNG 	;PRINT MSG
 		LEAX -1,Y 	;GET ERROR ADDRESS IN X-REG
 		LBSR OUT4H 	;OUTPUT IT
 		PSHS X 		;PUSH ERROR ADDR ON STACK
 		LDX  #MSG8  	;POINT TO MSG " =>"
 		LBSR PDATA  	;PRINT MSG
 		PULS X 		;POP ERROR ADDR FROM STACK
 		LBSR LRA 	;GET PHYSICAL ADDR FROM LRA
 		LBSR XASCII 	;OUTPUT EXTENDED 4 BITS OF PHYSICAL ADDR
 		LBSR OUT4H 	;OUTPUT LS 16 BITS OF PHYSICAL ADDR
 		LDX  #MSG6  	;POINT TO MSG ", PASS "
 		LBSR PDATA  	;PRINT MSG
 		LDX  4,S 		;LOAD PASS COUNT
 		LBSR OUT4H 	;OUTPUT IT
 		LDX  #MSG7 	;POINT TO MSG ", BITS IN ERROR
 		LBSR PDATA  	;PRINT MSG
 		TFR  B,A 	;GET ERROR BYTE INTO A-ACC
 		LDX  #MSG9 	;POINT TO MSG "76543210"
 		LBSR BIASCI 	;OUTPUT IN BINARY/ASCII FORMAT
 		LBSR INCHEK 	;CHECK FOR INPUT FROM KEYBOARD $FA56
 		BNE  ADJSK6 	;IF SO, EXIT MEMORY TEST
GUDPAS 	CMPY ,S 	;COMPARE END ADDR TO BEGIN ADDR
 		BCS  TEST1
 		LDA  #'+ 		;GET "PASS" SYMBOL IF MEMORY PASS OK
 		LBSR OUTCH 	;OUTPUT SYMBOL TO TERMINAL
 		LBSR INCHEK 	;INPUT FROM KEYBOARD?
 		BNE  ADJSK6 	;IF SO, EXIT MEMORY TEST
 		LDY  2,S 	;LOAD BEGIN ADDRESS
 		INC  5,S 		;INCREMENT LS BYTE OF PASS COUNT
 		BNE  MEMSET 	;IF NOT ZERO, SET NEXT MEMORY BYTE
 		INC  4,S 		;INCREMENT MS BYTE OF PASS COUNT
 		BNE  MEMSET 	;DONE WITH 65,535 PASSES OF MEMORY?
ADJSK6 	LEAS 6,S 	;ADJ STACK POINTER BY 6
 		RTS




***** "B" SET BREAKPOINT *****
BRKPNT 	LBSR IN1ADR 	;GET BREAKPOINT ADDRESS
 		BVS  EXITBP 	;EXIT IF INVALID HEX ADDR.
 		CMPX #STACK 	;ADDRESS ILLEGAL IF >=$DFC0
 		BCC  BPERR 	;IF ERROR PRINT (?), EXIT
 		PSHS X 		;$FA82 PUSH BP ADDRESS ON STACK
 		LDX  #$FFFF 	;LOAD DUMMY ADDR TO TEST BP TABLE
 		BSR BPTEST 	;TEST BP TABLE FOR FREE SPACE
 		PULS X 		;POP BP ADDRESS FROM STACK
 		BEQ  BPERR 	;(Z) SET, OUT OF BP TABLE SPACE
 		LDA  ,X 		;GET DATA AT BREAKPOINT ADDRESS
 		CMPA #$3F 	;IS IT A SWI?
 		BEQ  BPERR 	;IF SWI ALREADY, INDICATE ERROR
 		STA  ,Y+ 	;SAVE DATA BYTE IN BP TABLE
 		STX  ,Y 		;SAVE BP ADDRESS IN BP TABLE
 		LDA  #$3F 	;LOAD A SWI ($3F)
 		STA  ,X 		;SAVE SWI AT BREAKPOINT ADDRESS
EXITBP 		RTS

*  INDICATE ERROR SETTING BREAKPOINT

BPERR 		LBSR OUT1S 	;OUTPUT SPACE
 		LDA  #'? 		;LOAD (?), INDICATE BREAKPOINT ERROR
 		LBRA OUTCH 	;PRINT "?"

*** "X" CLEAR OUTSTANDING BREAKPOINTS ***
XBKPNT          LDY  #BPTBL     ;POINT TO BREAKPOINT TABLE
 		LDB  #8 		;LOAD BREAKPOINT COUNTER
XBPLP           BSR RPLSWI      ;REMOVE USED ENTRY IN BP TABLE
 		DECB  		;$FAAC DECREMENT BP COUNTER
 		BNE XBPLP 	;END OF BREAKPOINT TABLE?
 		RTS

***** SWI ENTRY POINT *****

SWIE 		TFR  S,U 	;TRANSFER STACK TO USER POINTER
 		LDX  10,U 	;LOAD PC FROM STACK INTO X-REG
 		LEAX -1,X 	;ADJUST ADDR DOWN 1 BYTE.
 		BSR BPTEST 	;FIND BREAKPOINT IN BP TABLE
 		BEQ  REGPR 	;IF FOUND, REPLACE DATA AT BP ADDR
 		STX  10,U 	;SAVE BREAKPOINT ADDR IN STACK
 		BSR RPLSWI 	;GO REPLACE SWI WITH ORIGINAL DATA
REGPR           LBSR REGSTR     ;GO PRINT REGISTERS
 		LBRA NEXTCMD 	;GET NEXT COMMAND
RPLSWI          LDX  1,Y                ;LOAD BP ADDRESS FROM BP TABLE
 		CMPX #STACK 	;COMPARE TO TOP AVAILABLE USER MEMORY
 		BCC  FFSTBL 	;GO RESET TABLE ENTRY TO $FF'S
 		LDA  ,X 		;GET DATA FROM BP ADDRESS
 		CMPA #$3F 	;IS IT SWI?
 		BNE  FFSTBL 	;IF NOT, RESET TABLE ENTRY TO $FF'S
 		LDA  ,Y 		;GET ORIGINAL DATA FROM BP TABLE
 		STA  ,X      	;$FAD3 RESTORE DATA AT BP ADDRESS
FFSTBL 	LDA  #$FF 	;LOAD $FF IN A-ACC
 		STA  ,Y+ 	;RESET BREAKPOINT TABLE DATA TO $FF'S
 		STA  ,Y+ 	;RESET BREAKPOINT TABLE ADDR TO $FF'S
 		STA  ,Y+
 		RTS

** SEARCH BREAKPOINT TABLE FOR MATCH **

BPTEST 	LDY  #BPTBL 	;POINT TO BREAKPOINT TABLE
 		LDB  #8 		;LOAD BREAKPOINT COUNTER
FNDBP 	LDA  ,Y+ 	;LOAD DATA BYTE
 		CMPX ,Y++ 	;COMPARE ADDRESS, IS IT SAME?
 		BEQ  BPADJ 	;IF SO, ADJUST POINTER FOR TABLE ENTRY
 		DECB 		;IF NOT, DECREMENT BREAKPOINT COUNTER
 		BNE  FNDBP 	;AND LOOK FOR NEXT POSSIBLE MATCH
 		RTS

BPADJ 	LEAY -3,Y 	;MOVE POINTER TO BEGIN OF BP ENTRY
 		RTS



*** "D" (WAS DISK BOOT ROUTINE FOR DMAF2) ***
DBOOT           JSR     Eprom2
                RTS             ;RETURNS TO NEXTCMD



***** LRA LOAD REAL ADDRESS *****

* THE FOLLOWING CODE LOADS THE 20-BIT
* PHYSICAL ADDRESS OF A MEMORY BYTE
* INTO THE "A" AND "X" REGISTERS. THIS
* ROUTINE IS ENTERED WITH THE LOGICAL
* ADDRESS OF A MEMORY BYTE IN THE "IX"
* REGISTER. EXIT IS MADE WITH THE HIGH-
* ORDER FOUR BITS OF THE 20-BIT PHYSICAL
* ADDRESS IN THE "A" REGISTER, AND THE
* LOW-ORDER 16-BITS OF THE 20-BIT
* PHYSICAL ADDRESS IN THE "IX" REGISTER.
* ALL OTHER REGISTERS ARE PRESERVED.
* THIS ROUTINE IS REQUIRED SINCE THE
* DMAF1 AND DMAF2 DISK CONTROLLERS MUST
* PRESENT PHYSICAL ADDRESSES ON THE
* SYSTEM BUS.

LRA 		PSHS A,B,X,Y 	;PUSH REGISTERS ON STACK
 		LDA  2,S 	;GET MSB LOGICAL ADDR FRM X REG ON STACK
 		LSRA
 		LSRA 		;ADJ FOR INDEXED INTO
 		LSRA 		;CORRESPONDING LOCATION
 		LSRA 		;IN LRA TABLE
 		LDY  #LRARAM 	;LOAD LRA TABLE BASE ADDRESS
 		LDB  A,Y 	;GET PHYSICAL ADDR. DATA FROM LRA TABLE
 		LSRB 		;ADJ. REAL ADDR. TO REFLECT EXTENDED
 		LSRB 		;PHYSICAL ADDRESS.
 		LSRB 		;EXTENDED MS 4-BITS ARE RETURNED
 		LSRB 		;IN THE "A" ACCUMULATOR
 		STB  ,S 		;MS 4 BITS IN A ACCUM. STORED ON STACK
 		LDB  A,Y 	;LOAD REAL ADDRESS DATA FROM LRA TABLE
 		COMB 		;COMP TO ADJ FOR PHYSICAL ADDR. IN X REG
 		ASLB 		;ADJ DATA FOR RELOCATION IN X REG
 		ASLB
 		ASLB       	;$FB97
 		ASLB
 		LDA  2,S 	;GET MS BYTE OF LOGICAL ADDR.
 		ANDA #$0F 	;MASK MS NIBBLE OF LOGICAL ADDRESS
 		STA  2,S 		;SAVE IT IN X REG ON STACK
 		ORB  2,S 	;SET MS BYTE IN X REG TO ADJ PHY ADDR.

* PLUS LS NIBBLE OF LOGICAL ADDRESS
 		STB  2,S 	;SAVE AS LS 16 BITS OF PHY ADDR IN X REG
* ON STACK
 		PULS A,B,X,Y 	;POP REGS. FROM STACK
 		RTS



* DELAY LOOP
DLY 		PSHS B 		;SAVE CONTENTS OF "B"
 		LDB  #$20 	;GET LOOP DELAY VALUE
SUB1 		DECB 		;SUBTRACT ONE FROM VALUE
 		BNE  SUB1 	;LOOP UNTIL ZERO
 		PULS B 		;RESTORE CONTENTS OF "B"
 		RTS



***** "U" MINIDISK BOOT *****
MINBOOT 	TST  Comreg
 		CLR  Drvreg  	;SELECT DRIVE 0

* DELAY BEFORE ISSUING RESTORE COMMAND
 		LDB  #3
 		LDX  #0
LOOP 		LEAX 1,X      	;$FBBB
 		CMPX #0
 		BNE  LOOP
 		DECB                	;$FBC2
 		BNE  LOOP

 		LDA  #$0F 	;*LOAD HEAD, VERIFY, 20msec/step
 		STA  Comreg  	;ISSUE RESTORE COMMAND
 		BSR DELAY
LOOP1 	LDB  Comreg      	;$FBCC
 		BITB #1
 		BNE  LOOP1  	;LOOP UNTIL THRU
 		LDA  #1
 		STA  Secreg 	;SET SECTOR REGISTER TO ONE
 		BSR DELAY
 		LDA  #$8C  	;LOAD HEAD, DELAY 10msec,
 		STA  Comreg  	;AND READ SINGLE RECORD
 		BSR DELAY
 		LDX  #$C000
 		BRA  LOOP3

LOOP2 	BITB #2      	;$FBE6 DRQ?
 		BEQ  LOOP3
 		LDA  Datreg
 		STA  ,X+

LOOP3 	LDB  Comreg 	;FETCH STATUS
 		BITB #1  		;BUSY?
 		BNE  LOOP2
 		BITB #$2C 	;CRC ERROR OR LOST DATA?
 		BEQ  LOOP4
 		RTS
LOOP4 	LDX  #$C000        ;$FBFB
 		STX  10,U
 		TFR  U,S
 		RTI

* DELAY
DELAY 	LDB  #$20
LOOP5 	DECB
 		BNE  LOOP5
 		RTS





***** "L" LOAD MIKBUG TAPE *****
LOAD 		RTS 	;REMOVED "L" COMMAND

***** "P" PUNCH MIKBUG TAPE *****
PUNCH 	RTS	;REMOVED "P" COMMAND





PRTSP 	LDX  #MSG10 	;POINT TO MSG "SP="
 		LBSR PDATA  	;PRINT MSG
 		TFR  U,X
 		LBRA OUT4H
PRTUS 	LDX  #MSG12 	;POINT TO MSG "US="
 		LBSR PDATA  	;PRINT MSG
 		LDX  8,U
 		LBRA OUT4H
PRTDP 	LDX  #MSG15 	;POINT TO MSG "DP="
 		LBSR PDATA  	;PRINT MSG
 		LDA  3,U
 		LBRA OUT2H 	;OUTPUT HEX BYTE AS ASCII
PRTIX 	LDX  #MSG14 	;POINT TO MSG "IX="
 		LBSR PDATA  	;PRINT MSG
 		LDX  4,U      	;$FCE6
 		LBRA OUT4H
PRTIY 	LDX  #MSG13 	;POINT TO MSG "IY="
 		LBSR PDATA  	;PRINT MSG
 		LDX  6,U
 		LBRA  OUT4H
PRTPC 	LDX  #MSG11 	;POINT TO MSG "PC="
 		LBSR PDATA  	;PRINT MSG
 		LDX  10,U
 		BRA  OUT4H
PRTA 		LDX  #MSG16 	;POINT TO MSG "A="
 		LBSR PDATA  	;PRINT MSG
 		LDA  1,U
 		BRA OUT2H 	;OUTPUT HEX BYTE AS ASCII
PRTB 		LDX  #MSG17 	;POINT TO MSG "B="
 		LBSR PDATA  	;PRINT MSG
 		LDA  2,U
 		BRA OUT2H 	;OUTPUT HEX BYTE AS ASCII
PRTCC 	LDX  #MSG18 	;POINT TO MSG "CC:"
 		LBSR PDATA  	;PRINT MSG
 		LDA  ,U
 		LDX  #MSG19 	;POINT TO MSG "EFHINZVC"
 		BRA BIASCI 	;OUTPUT IN BINARY/ASCII FORMAT




* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT TWO VALID HEX ADDRESSES.
* THE FIRST ADDRESS INPUT IS RETURNED IN "IY".
* THE SECOND IS RETURNED IN "IX". THE "V" BIT
* IN THE C-CODE REG. IS SET IF AN INVALID HEX
* ADDRESS IS INPUT.
IN2ADR 	BSR IN1ADR 	;GET FIRST ADDRESS
 		BVS NOTHEX 	;EXIT IF NOT VALID HEX
 		TFR  X,Y 	;SAVE FIRST ADDR. IN "IY"
 		LDA #'-
 		LBSR OUTCH 	;PRINT " - "


* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE
* ADDRESS IS RETURNED IN THE "X" REGISTER.
IN1ADR 	BSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS NOTHEX 	;EXIT IF NOT VALID HEX
 		TFR  D,X
 		BSR BYTE 	;INPUT BYTE (2 HEX CHAR)
 		BVS NOTHEX
 		PSHS X
 		STA  1,S
 		PULS X
 		RTS

***** INPUT BYTE (2 HEX CHAR.) *****
BYTE 		BSR INHEX 	;GET HEX LEFT
 		BVS NOTHEX 	;EXIT IF NOT VALID HEX
 		ASLA
 		ASLA
 		ASLA 		;SHIFT INTO LEFT NIBBLE
		ASLA
 		TFR  A,B 	;PUT HEXL IN "B"
 		BSR INHEX 	;GET HEX RIGHT
 		BVS NOTHEX 	;EXIT IF NOT VALID HEX
 		PSHS B 		;PUSH HEXL ON STACK
 		ADDA ,S+ 	;ADD HEXL TO HEXR AND ADJ. STK
 		RTS 		;RETURN WITH HEX L&R IN "A"


INHEX 	BSR ECHON 	;INPUT ASCII CHAR.
 		CMPA #'0 	;IS IT > OR = "0" ?
 		BCS NOTHEX 	;IF LESS IT AIN'T HEX
 		CMPA #'9 	;IS IT < OR = "9" ?
 		BHI INHEXA 	;IF > MAYBE IT'S ALPHA
 		SUBA #$30 	;ASCII ADJ. NUMERIC
 		RTS


INHEXA 	CMPA #'A 	;IS IT > OR = "A"
 		BCS NOTHEX 	;IF LESS IT AIN'T HEX
 		CMPA #'F 	;IS IT < OR = "F" ?
 		BHI INHEXL 	;IF > IT AIN'T HEX
 		SUBA #$37 	;ASCII ADJ. ALPHA
 		RTS

INHEXL 	CMPA #'a 	;IS IT > OR = "a"
 		BCS NOTHEX 	;IF LESS IT AIN'T HEX
 		CMPA #'f 	;IS IT < "f"
 		BHI NOTHEX 	;IF > IT AIN'T HEX
 		SUBA #$57 	;ADJUST TO LOWER CASE
 		RTS


NOTHEX 	ORCC #2 	;SET (V) FLAG IN C-CODES REGISTER
 		RTS


OUT4H 	PSHS X 		;PUSH X-REG. ON THE STACK
 		PULS A 		;POP MS BYTE OF X-REG INTO A-ACC.
 		BSR OUTHL 	;OUTPUT HEX LEFT
 		PULS A 		;POP LS BYTE OF X-REG INTO A-ACC.

OUTHL 	EQU *
OUT2H 	PSHS A 		;SAVE IT BACK ON STACK
 		LSRA 		;CONVERT UPPER HEX NIBBLE TO ASCII
 		LSRA
 		LSRA
 		LSRA
 		BSR XASCII 	;PRINT HEX NIBBLE AS ASCII

OUTHR 	PULS A 		;CONVERT LOWER HEX NIBBLE TO ASCII
 		ANDA #$0F 	;STRIP LEFT NIBBLE
XASCII 	ADDA #$30 	;ASCII ADJ
 		CMPA #$39 	;IS IT < OR = "9" ?
 		BLE  OUTC 	;IF LESS, OUTPUT IT
 		ADDA #7 	;IF > MAKE ASCII LETTER
OUTC 		BRA  OUTCH 	;OUTPUT CHAR



* BINARY / ASCII --- THIS ROUTINE
* OUTPUTS A BYTE IN ENHANCED
* BINARY FORMAT. THE ENHANCEMENT
* IS DONE BY SUBSTITUTING ASCII
* LETTERS FOR THE ONES IN THE BYTE.
* THE ASCII ENHANCEMENT LETTERS
* ARE OBTAINED FROM THE STRING
* POINTED TO BY THE INDEX REG. "X".
BIASCI 	PSHS A 		;SAVE "A" ON STACK
 		LDB  #8 		;PRESET LOOP# TO BITS PER BYTE
OUTBA 	LDA ,X+ 		;GET LETTER FROM STRING
 		ASL  ,S 		;TEST BYTE FOR "1" IN B7
 		BCS PRTBA 	;IF ONE PRINT LETTER
 		LDA #'- 		;IF ZERO PRINT "-"
PRTBA 	BSR OUTCH 	;PRINT IT
 		BSR OUT1S 	;PRINT SPACE
 		DECB 		;SUB 1 FROM #BITS YET TO PRINT
 		BNE OUTBA
 		PULS A
 		RTS


* PRINT STRING PRECEEDED BY A CR & LF.
PSTRNG 	BSR PCRLF 	;PRINT CR/LF
 		BRA  PDATA  	;PRINT STRING POINTED TO BY IX

* PCRLF

PCRLF 	PSHS X 		;SAVE IX
 		LDX  #MSG2+1  	;POINT TO MSG CR/LF + 3 NULS
 		BSR PDATA  	;PRINT MSG
 		PULS X 		;RESTORE IX
 		RTS
PRINT 	BSR OUTCH



* PDATA
PDATA 	LDA  ,X+ 		;GET 1st CHAR. TO PRINT
 		CMPA #4 	;IS IT EOT?
 		BNE  PRINT 	;IF NOT EOT PRINT IT
 		RTS


ECHON 	TST  ECHO 	;IS ECHO REQUIRED ?
 		BEQ  INCH 	;ECHO NOT REQ. IF CLEAR


* INCHE
* ---GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.
INCHE 	BSR INCH 	;GET CHAR FROM TERMINAL
 		ANDA #$7F      	;STRIP PARITY FROM CHAR.
 		BRA  OUTCH     	;ECHO CHAR TO TERMINAL

* INCH
* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.
INCH 		PSHS X 		;SAVE IX
 		LDX  CPORT 	;POINT TO TERMINAL PORT
GETSTA 	LDA  ,X  		;FETCH PORT STATUS
 		BITA #1 		;TEST READY BIT, RDRF ?
 		BEQ  GETSTA 	;IF NOT RDY, THEN TRY AGAIN
 		LDA  1,X 		;FETCH CHAR
 		PULS X 		;RESTORE IX
 		RTS


* INCHEK
* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.
INCHEK 	PSHS A 		;SAVE A ACCUM.
 		LDA  [CPORT] 	;FETCH PORT STATUS
 		BITA #1 		;TEST READY BIT, RDRF ?
 		PULS A 		;RESTORE A ACCUM.
 		RTS

OUT2S 	BSR OUT1S 	;OUTPUT 2 SPACES
OUT1S 	LDA  #$20  	;OUTPUT 1 SPACE



* OUTCH
* OUTPUT CHARACTER TO TERMINAL.
* THE CHAR. TO BE OUTPUT IS
* PASSED IN THE A REGISTER.
* ALL REGISTERS ARE PRESERVED.
OUTCH 	PSHS A,X 	;SAVE A ACCUM AND IX
 		LDX  CPORT 	;GET ADDR. OF TERMINAL
FETSTA 	LDA  ,X 		;FETCH PORT STATUS
 		BITA #2 		;TEST TDRE, OK TO XMIT ?
 		BEQ  FETSTA 	;IF NOT LOOP UNTIL RDY
 		PULS A 		;GET CHAR. FOR XMIT
 		STA  1,X 		;XMIT CHAR.
 		PULS X 		;RESTORE IX
 		RTS





ACINIZ 	LDX  CPORT  	;POINT TO CONTROL PORT ADDRESS
 		LDA  #3  		;RESET ACIA PORT CODE
 		STA  ,X  		;STORE IN CONTROL REGISTER
 		LDA  #$11  		;SET 8 DATA, 2 STOP AN 0 PARITY
 		STA  ,X  		;STORE IN CONTROL REGISTER
 		TST  1,X  		;ANYTHING IN DATA REGISTER?
 		LDA  #$FF  		;TURN ON ECHO FLAG
 		STA  ECHO
 		RTS



* MONITOR KEYBOARD COMMAND JUMP TABLE

JMPTAB EQU *
 	FCB 1 		;" ^A "  $F91D
 	FDB ALTRA
 	FCB 2 		;" ^B "  $F90F
 	FDB ALTRB
 	FCB 3 		;" ^C "  $F92B
 	FDB ALTRCC
 	FCB 4 		;" ^D "  $F901
 	FDB ALTRDP
 	FCB $10 		;" ^P "  $F8C9
 	FDB ALTRPC
 	FCB $15 		;" ^U "  $F8D7
 	FDB ALTRU
 	FCB $18 		;" ^X "  $F8F3
 	FDB ALTRX
 	FCB $19 		;" ^Y "  $F8E5
 	FDB ALTRY

 	FCC 'B'
 	FDB BRKPNT 	;*$FA78
 	FCC 'D'
 	FDB DBOOT 	;*$FAF1
 	FCC 'E'
 	FDB MEMDUMP 	;*$F990
 	FCC 'G'
 	FDB GO 		;*$F89F
 	FCC 'L'
 	FDB LOAD 	;*$FC09
 	FCC 'M'
 	FDB MEMCHG 	;*$F93B
 	FCC 'P'
 	FDB PUNCH 	;*$FC64
 	FCC 'Q'
 	FDB MEMTST 	;*$F9EF
 	FCC 'R'
 	FDB REGSTR 	;*$F8A2
 	FCC 'S'
 	FDB DISSTK 	;*$F984
 	FCC 'U'
 	FDB MINBOOT 	;*$FBB0
 	FCC 'X'
 	FDB XBKPNT 	;*$FAA4

TABEND EQU *


* ** 6809 VECTOR ADDRESSES **
* FOLLOWING ARE THE ADDRESSES OF THE VECTOR ROUTINES
* FOR THE 6809 PROCESSOR. DURING INITIALIZATION THEY
* ARE RELOCATED TO RAM FROM $DFC0 TO $DFCF. THEY ARE
* RELOCATED TO RAM SO THAT THE USER MAY REVECTOR TO
* HIS OWN ROUTINES IF HE SO DESIRES.
RAMVEC 	FDB 	SWIE  	;USER-V
 		FDB 	RTI    	;SWI3-V
 		FDB 	RTI    	;SWI2-V
 		FDB 	RTI    	;FIRQ-V
 		FDB 	RTI    	;IRQ-V
 		FDB 	SWIE   	;SWI-V
 		FDB 	$FFFF  	;SVC-VO
 		FDB 	$FFFF  	;SVC-VL


* PRINTABLE MESSAGE STRINGS

MSG1 		FCB 	$0,$0,$0,$D,$A,$0,$0,$0 	;0, CR/LF, 0
                FCC     "S-BUG1.8+ NF2025 - "
 		FCB 	4

MSG2 		FCB 	'K,$D,$A,$0,$0,$0,4 	;K, * CR/LF + 3 NULS

MSG3 		FCC 	'>'
 		FCB 	4

MSG4 		FCC 	"WHAT?"
 		FCB 	4

MSG5 		FCC 	'- '
 		FCB 	4

MSG6 		FCC 	", PASS "
 		FCB 	4

MSG7 		FCC 	", BITS IN ERROR: "
 		FCB 	4

MSG8 		FCC 	" => "
 		FCB 	4

MSG9 		FCC 	"76543210"
MSG10 		FCC 	"  SP="
 		FCB 	4

MSG11 		FCC 	"  PC="
 		FCB 	4

MSG12 		FCC 	"  US="
 		FCB 	4

MSG13 		FCC 	"  IY="
 		FCB 	4

MSG14 		FCC 	"  IX="
 		FCB 	4

MSG15 		FCC 	"  DP="
 		FCB 	4

MSG16 		FCC 	"  A="
 		FCB 	4

MSG17 		FCC 	"  B="
 		FCB 	4

MSG18 		FCC 	"  CC: "
 		FCB 	4

MSG19 		FCC 	"EFHINZVC"
MSG20 		FCC 	"S1"
 		FCB 	4



* MESSAGE EXPANSION AREA

 		FCB 	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 		FCB 	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF

*SPARE BYTES
 ORG *
 FILL 255,310
		
 ORG *



* POWER UP/ RESET/ NMI ENTRY POINT INITIALISATION
 ORG $FF00
START 		LDS	#STACK
		LDX	#$DFD0	;SET LRA RAM FOR FIXED 56K RAM 0000-DFFF
		LDA	#$0F	;INSTEAD OF ORIGINAL ADDRESS TEST/TRANSLATION
ASLOOP		STA	,X+	; FOR MY HARDWARE WITH MAX 64K ADDRESS SPACE
		DECA
		BNE 	ASLOOP
		LDA	#$F1
		STA 	$DFDE
		DECA
		STA	$DFDF

		CLRA		;SET ECHO FLAG TRUE
		COMA
		STA	ECHO
		
		LBRA	MONITOR	;JUMP INTO MONITOR




V1 JMP  [STACK]
V2 JMP  [SWI2]
V3 JMP  [FIRQ]
V4 JMP  [IRQ]
V5 JMP  [SWI]



* SWI3 ENTRY POINT
SWI3E 	TFR  S,U
 		LDX  10,U      	;*$FFC8
 		LDB  ,X+
 		STX  10,U
 		CLRA
 		ASLB
 		ROLA
 		LDX  SVCVO
 		CMPX #$FFFF
 		BEQ  SWI3Z
 		LEAX D,X
 		CMPX SVCVL
 		BHI  SWI3Z
 		PSHS X
 		LDD  ,U
 		LDX  4,U
 		JMP  [,S++]
SWI3Z 	PULU A,B,X,CC,DP
 		LDU  2,U
 		JMP  [SWI3]



 ORG $FF60
 FILL 255,144
 ORG *


* 6809 VECTORS
 ORG $FFF0
 		FDB V1    	;USER-V
 		FDB SWI3E 	;SWI3-V
 		FDB V2    	;SWI2-V
 		FDB V3    	;FIRQ-V
 		FDB V4    	;IRQ-V
 		FDB V5    	;SWI-V
 		FDB V1    	;NMI-V
 		FDB START 	;RESTART-V
 END


 

